#include "Config.h"
#include "Spi.h"
#include "NOKIA5110.h"
#include "Mt.h"

//---------------------------------
// Биты управления модулем SPI
//---------------------------------
// SPI2X  SPR1  SPR0 SCK Frequensy
//   0     1     1    Fosc / 128
//   1     1     1    Fosc / 64
//   0     1     0    Fosc / 64
//   1     1     0    Fosc / 32
//   0     0     1    Fosc / 16
//   1     0     1    Fosc / 8
//   0     0     0    Fosc / 4
//   1     0     0    Fosc / 2




#define ST_UNKNOWN	0
#define ST_LCD		1

#define	SPI_SIZE_BUF	40 // Размер буфера SPI




///////////////////////////////////////////////////////////////////////////////
// Переменные
///////////////////////////////////////////////////////////////////////////////

// Буфер для передачи и приема.
static	uint8_t SPI_Buf[SPI_SIZE_BUF];

static	int16_t SPI_Cnt; // Счетчик оставшихся для передачи байтов
static	uint8_t *SPI_AddrBuf; // Адрес передаваемого буфера
static	uint8_t SPI_Status = ST_UNKNOWN;
static	uint8_t SPI_Busy = 0; // Флаг занятости
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Обработчик прерывания SPI.
///////////////////////////////////////////////////////////////////////////////
ISR(SPI_STC_vect)
{
	if (SPI_Status == ST_LCD)
	{
		if (SPDR); // Нужно только прочитать порт данных. Данные не нужны.
	}
	else
	{
		*SPI_AddrBuf = SPDR; // Сохраняем принятый байт данных.
	}
	
	SPI_AddrBuf++; // Наращиваем указатель буфера

	SPI_Cnt--; // Декремент счетчика переданных байтов

	if (SPI_Cnt > 0)
	{
		SPDR = *SPI_AddrBuf; // Передаем следующий байт
	}
	else
	{
		// Снимаем выборку подчиненного устройства
		OFF(NOKIA5110_CE);

		SPI_Busy = 0; // Снимаем занятость SPI

		// Активируем задачи, которые ждут обслуживания
		MT_DrvTaskRunIrq(DRV_SPI);
	}
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Инициализация модуля SPI
///////////////////////////////////////////////////////////////////////////////
void SPI_Init(void)
{
	DRIVER(NOKIA5110_DIN, OUT); // выход
	DRIVER(NOKIA5110_CLK, OUT); // выход
	
	DRIVER(NOKIA5110_CE, OUT); // выход
	OFF(NOKIA5110_CE); // Снимаем выборку индикатора
	
	SPI_Cnt = 0;
	SPI_Status = ST_UNKNOWN;
	SPI_Busy = 0;
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Инициализация SPI для работы с индикатором NOKIA-5110 в режиме MASTER.
// Максимальная частота SCK = 4MHz.
///////////////////////////////////////////////////////////////////////////////
static void SPI_Init_LCD(void)
{
	if (SPI_Status == ST_LCD) return;
	SPI_Status = ST_LCD;

	// MSB, ~|_|
	// Данные передаются старшим битом вперед
	// Fspi=Fosc/4

	// SPR1 SPR0
	// 0,0 - F_CPU / 4
	// 0,1 - F_CPU / 16
	// 1,0 - F_CPU / 64
	// 1,1 - F_CPU / 128	
	SPCR = (0<<SPIE)|(0<<SPE)|(0<<DORD)|(1<<MSTR)|(1<<CPOL)|(1<<CPHA)|
		(0<<SPR1)|(0<<SPR0);
	
	#if (F_CPU <= 8000000UL)
	SPSR = 1<<SPI2X; // Частота SPI x 2
	#else
	SPSR = 0<<SPI2X; // Частота SPI x 1
	#endif

	SPCR |= 1<<SPE; // Разрешаем SPI
	while (SPSR & (1<<SPIF)) {if SPDR;}; // Очищаем флаг SPIF
	SPCR |= 1 << SPIE; // Разрешаем прерывания SPI
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Если драйвер SPI занят, то функция возвращает FALSE и переводит текущую
// задачу в ждущее состояние.
///////////////////////////////////////////////////////////////////////////////
uint8_t SPI_WaitReady(void)
{
	ENTER_CRITICAL(); // Вход в критическую секцию
	if (SPI_Busy)
	{
		MT_DrvTaskWaitIrq(DRV_SPI); // Перевод текущей задачи в ждущее
									// состояние
		EXIT_CRITICAL(); // Выход из критической секции
		return FALSE; // Драйвер занят
	}
	EXIT_CRITICAL(); // Выход из критической секции
	return TRUE; // Драйвер готов выполнить запрос
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Передает один байт в индикатор.
// Функция копирует передаваемый байт в буфер драйвера SPI, после чего
// запускает передачу ведомому устройству.
// ПРИМЕЧАНИЕ:
// Эту ф-ю можно вызывать только если драйвер SPI свободен.
// Проверить занятость драйвера можно с помощью SPI_WaitReady().
///////////////////////////////////////////////////////////////////////////////
void SPI_SendByteToLCD(uint8_t Value)
{
	if (SPI_Busy) return;

	// Копируем передаваемый байт в буфер SPI
	SPI_Buf[0] = Value;
	SPI_AddrBuf = SPI_Buf;

	SPI_Cnt = 1;
	SPI_Busy = 1;

	SPI_Init_LCD();
	ON(NOKIA5110_CE);
	SPDR = SPI_Buf[0];
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Функция запускает передачу данных ведомому устройству.
// ПРИМЕЧАНИЕ:
// Эту ф-ю можно вызывать только если драйвер SPI свободен.
// Проверить занятость драйвера можно с помощью SPI_WaitReady().
// Массив данных, адресуемый параметром Buf не должен изменяться до окончания
// передачи.
// Параметры:
// Buf - Адрес массива данных для передачи
// Size - Размер передаваемых данных в байтах
///////////////////////////////////////////////////////////////////////////////
void SPI_SendBufPtrToLCD(uint8_t *Buf, uint8_t Size)
{
	if (SPI_Busy) return;
	if (Size == 0) return;

	SPI_AddrBuf = Buf; // Запоминаем указатель на буфер	
	SPI_Cnt = Size;
	SPI_Busy = 1;

	SPI_Init_LCD();

	ON(NOKIA5110_CE);
	SPDR = *SPI_AddrBuf; // Посылаем самый первый байт
}
///////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Возвращает состояние готовности драйвера SPI.
///////////////////////////////////////////////////////////////////////////////
uint8_t SPI_Ready(void)
{
	if (SPI_Busy) return FALSE;
	return TRUE;
}
///////////////////////////////////////////////////////////////////////////////
